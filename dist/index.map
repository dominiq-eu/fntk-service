{"version":3,"sources":["data/app.js","data/request.js","utils/index.js","data/response.js","gateways/http/web-service.js","gateways/http/index.js","gateways/telegram/index.js","middleware/nlp.js","index.js"],"names":["App","fn","x","sources","layer","s","concat","l","f","dataPipeline","reduce","g","forEach","module","exports","Type","Data","Union","String","Object","require","RequestType","NLPRequestType","v","is","sentence","Request","randomBetween","min","max","Math","floor","random","list","length","Result","RandomOkType","Ok","data_list","Response","Err","Express","Compression","BodyParser","Url","Http","HttpHeader","HttpRequest","isObject","obj","toPromise","p","then","Promise","resolve","toString","response","JSON","stringify","isObjEmpty","Boolean","keys","app","use","json","urlencoded","extended","all","req","res","next","url","parse","log","request","method","headers","pathname","query","body","r","write","end","program","port","prog","createServer","listen","WebService","cfg","http","path","data","TeleBot","token","parseMode","bot","on","msg","NLP","text","answer","value","sendMessage","from","id","message_id","catch","e","start","Snowball","Natural","NlpToolkit","StopwordsIso","Fs","Language","State","trace","a","getSubDirs","dir","readdirSync","map","file","filter","statSync","isDirectory","ret","d","getNlpFunctions","sentences","de","en","push","replace","cleanStopwords","lang","split","w","includes","join","trim","StemmSnowball","stemmer","cleanedText","toLowerCase","setCurrent","stem","getCurrent","Normalize","tokenizer","stemmed","calcSimilarity","withStr","matchStr","s1","s2","JaroWinklerDistance","getMatch","sort","val_a","s_a","val_b","s_b","val","txt","getPropability","match","undefined","getMatches","functions","line","propability","b","findModule","reqRes","matchTable","fnPath","newRequest","global","include","__dirname","HTTPGateway","TelegramGateway","NLPMiddleware","Path","process","cwd","loadFunction","payload","Router","Error","Service","source","add","do"],"mappings":"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","file":"index.map","sourceRoot":"../src","sourcesContent":["/*\n    App.js\n\n    Provides a data structure for basic app behaivor.\n*/\n\n//\n// App\n//  * fn: The app logic\n//  * sources: A list of functions that act as data sources and generate data\n//  * layer: A list of functions that builds a pipeline and manipulate the\n//           data before reaching the app logic (fn)\n//\n// App :: Function -> List(Function) -> List(Function) -> Nothing\nconst App = (fn = x => x, sources = [], layer = []) => ({\n    // Here we register data sources. They can create data and feed in\n    // the system.\n    source: s => App(fn, sources.concat([s]), layer),\n\n    // Here we add a layer to manipulate the data on his way trough the\n    // system and before it reaches it's final processing.\n    // add: l => App(x => l(f(x))),\n    add: l => App(fn, sources, layer.concat([l])),\n\n    // Add the data processing\n    do: f => App(f, sources, layer),\n\n    // Start the app\n    start: () => {\n        // Build the data processing pipeline using composition.\n        const dataPipeline = layer\n            .concat(fn)\n            .reduce((f, g) => x => g(f(x)), x => x)\n\n        // Hand the data processing pipeline to the data sources,\n        // so that every source can pass new data to the app.\n        sources.forEach(s => s(dataPipeline))\n    }\n})\n\nmodule.exports = App\n","/*\n    Request\n\n    Provides a data structure that represents an incoming request.\n*/\n\nconst { Type, Data, Union, String, Object } = require('@fntk/types')\n\nconst RequestType = Data('Request', {\n    path: String,\n    payload: Object\n})\n\nconst NLPRequestType = Type(\n    'NLP',\n    v => Object.is(v) && v.sentence && String.is(v.sentence),\n    v => ({ sentence: String(v) })\n)\n\nconst Request = Union('Request', {\n    Request: RequestType,\n    NLP: NLPRequestType\n})\n\nmodule.exports = Request\n","export const randomBetween = (min, max) =>\n  Math.floor(Math.random() * (max - min + 1)) + min;\n\nexport const random = (list = []) => {\n  if (list.length > 0) {\n    const index = randomBetween(0, list.length - 1);\n    return list[index];\n  } else {\n    return randomBetween(0, 100);\n  }\n};\n","/*\n    Request\n\n    Provides a data structure that represents an incoming request.\n*/\n\nconst { Type, Union, Result } = require('@fntk/types')\nconst { random } = require('../utils')\n\nconst RandomOkType = Type(\n    'Random',\n    v => Result.Ok.is(v),\n    data_list => Result.Ok(random(data_list))\n)\n\nconst Response = Union('Response', {\n    Success: Result.Ok,\n    Error: Result.Err,\n    Random: RandomOkType\n})\n\nmodule.exports = Response\n","// Express\nconst Express = require('express')\nconst Compression = require('compression')\nconst BodyParser = require('body-parser')\n\n// Node\nconst Url = require('url')\nconst Http = require('http')\n\nconst { Data } = require('@fntk/types')\n\n//\n// -- Types\n//\n\nconst HttpHeader = Data('HTTPHeader', {\n    method: String,\n    url: String,\n    path: String,\n    headers: Object\n})\n\nconst HttpRequest = Data('HTTPRequest', {\n    http: HttpHeader,\n    data: Object\n})\n\n//\n// -- Helper\n//\nconst isObject = obj => obj !== null && typeof obj === 'object'\nconst toPromise = p => (p.then ? p : Promise.resolve(p))\nconst toString = response =>\n    isObject(response) ? JSON.stringify(response, null, 4) : response\nconst isObjEmpty = obj => Boolean(Object.keys(obj).length)\n\n// app :: ()\nconst app = fn =>\n    Express()\n        .use(Compression()) // Compression support\n        .use(BodyParser.json()) // Automatic parsing of the response body\n        .use(BodyParser.urlencoded({ extended: true }))\n        // Catch route\n        .all('*', (req, res, next) => {\n            const url = Url.parse(req.url, true)\n            console.log('URL:', url)\n            const request = HttpRequest({\n                http: HttpHeader({\n                    method: req.method,\n                    headers: req.headers,\n                    url: req.url,\n                    path: url.pathname\n                }),\n                data: isObjEmpty(url.query) ? url.query : req.body\n            })\n            console.log('Request:', request)\n            const handler = r => toPromise(fn(r))\n            handler(request)\n                .then(toString)\n                .then(response => {\n                    console.log('[WebService] Response: ', response)\n                    res.write(response)\n                    res.end()\n                })\n        })\n\n// program :: { Int, [ Route ]}\nconst program = fn => {\n    // Configuration\n    const port = 8000\n    const prog = app(fn)\n\n    Http.createServer(prog).listen(port, () => {\n        console.log(`Listening on port: ${port}`)\n    })\n}\n\nmodule.exports = { program }\n","/*\n    HttpListener\n\n    Listen to http events and forward them back to the app for handling.\n*/\n\nconst WebService = require('./web-service')\nconst Request = require('../../data/request')\n\n// Get http requests, send them to the system for processing and\n// send the response after successfull handling.\nmodule.exports = cfg => fn =>\n    WebService.program(request => {\n        console.log('Http:', request)\n        const req = Request.Request({\n            path: request.http.path,\n            payload: request.data\n        })\n        console.log('Request:', req)\n        return fn(req)\n    })\n","/*\n    telegram.js\n\n    Get updates from telegram.\n*/\n\nconst Request = require('../../data/request')\nconst TeleBot = require('telebot')\n\nconst toPromise = p => (p.then ? p : Promise.resolve(p))\n\nmodule.exports = ({ token, parseMode = 'text' }) => fn => {\n    const bot = new TeleBot({\n        token,\n        polling: {\n            interval: 1000\n        }\n    })\n\n    bot.on('text', msg => {\n        console.log('[Gateway] [Telegram] Request: ', msg)\n\n        const req = Request.NLP(msg.text)\n        const handle = req => toPromise(fn(req))\n        handle(req)\n            .then(response => {\n                console.log('[Gateway] [Telegram] Response: ', response)\n                const answer = String(response.value)\n                console.log('[Gateway] [Telegram] Answer: ', answer)\n                bot.sendMessage(msg.from.id, answer, {\n                    parseMode,\n                    replyToMessage: msg.message_id\n                })\n            })\n            .catch(e => {\n                console.log('[Gateway] [Telegram] Error:', e)\n                bot.sendMessage(msg.from.id, 'Internal Error', {\n                    replyToMessage: msg.message_id\n                })\n            })\n    })\n\n    bot.start()\n}\n","/*\n    Route sentences to modules using nlp technics.\n*/\n\n// const Franc = require('franc') // Language detection\n// const Tokenizer = require('./stem/tokenizer')\nconst Snowball = require('snowball')\nconst Natural = require('natural') // sentence similarity\nconst NlpToolkit = require('nlp-toolkit')\nconst StopwordsIso = require('stopwords-iso')\nconst Fs = require('fs')\n\nconst Request = require('../data/request')\nconst Response = require('../data/response')\n\n// Languages :: Languages\nconst Language = {\n    de: 'German',\n    en: 'English'\n}\n\n// State :: State\nconst State = {\n    lang: 'de',\n    functions: []\n}\n\n//\n// -- Utils\n//\n\n// trace :: String => a => a\nconst trace = msg => a => {\n    console.log(msg, a)\n    return a\n}\n\n// getSubDirs :: String => String[]\nconst getSubDirs = dir =>\n    Fs.readdirSync(dir)\n        // Convert the filename to a full path, filter out all\n        // directories and look recursively for more nested dirs.\n        .map(file => `${dir}/${file}`)\n        .filter(file => Fs.statSync(file).isDirectory())\n        .reduce(\n            (ret, d) =>\n                ret\n                    // Add found dirs to return value and look for\n                    // more nested dirs.\n                    .concat(d)\n                    .concat(getSubDirs(d)),\n            []\n        )\n\n// getNlpFunctions :: String => NlpFunction[]\nconst getNlpFunctions = dir =>\n    getSubDirs(dir).reduce((ret, path) => {\n        try {\n            const cfg = require(`${path}/function.json`)\n            // const fn = require(`${path}/index.js`)\n            if (cfg.sentences.de || cfg.sentences.en) {\n                // ret.push({ fn, sentences: cfg.sentences })\n                ret.push({\n                    path: path.replace(dir, ''),\n                    sentences: cfg.sentences\n                })\n            }\n        } catch (e) {\n            // Not found, or something else..\n            // console.error('NLPFunction:', e)\n        }\n        return ret\n    }, [])\n\n// cleanStopwords :: String => Language => String\nconst cleanStopwords = (text, lang) =>\n    text\n        // split sentence to an array of words\n        .split(' ')\n        // Filter all stopwords\n        .filter(w => !StopwordsIso[lang].includes(w))\n        // create string again\n        .join(' ')\n        .trim()\n\n// StemmSnowball :: String -> String\nconst StemmSnowball = text => {\n    if (text.length > 5) {\n        const stemmer = new Snowball(Language[State.lang])\n        const cleanedText = cleanStopwords(\n            text.toLowerCase().trim(),\n            State.lang\n        )\n        stemmer.setCurrent(cleanedText)\n        stemmer.stem()\n        return stemmer.getCurrent()\n    } else {\n        return text.toLowerCase()\n    }\n}\n\n// Normalize :: String -> String\nconst Normalize = text => {\n    const token = NlpToolkit.tokenizer(text)\n    const stemmed = NlpToolkit.stemmer(token, { lang: State.lang })\n    return cleanStopwords(stemmed.join(' ').trim(), State.lang)\n}\n\n// Normalize :: (String => String) -> String -> String -> { val: Number, msg: String }\nconst calcSimilarity = (stemmer, withStr, matchStr) => {\n    const s1 = stemmer(matchStr.toLowerCase().trim())\n    const s2 = stemmer(withStr.toLowerCase().trim())\n    const value = Natural.JaroWinklerDistance(s1, s2)\n\n    return [value, s1]\n}\n\nconst getMatch = (stemmer, text, sentences) =>\n    sentences\n        .map(s => calcSimilarity(stemmer, text, s))\n        .sort(([val_a, s_a], [val_b, s_b]) => val_b - val_a)\n        // .map(trace('#'))\n        .filter(([val, sentence]) => val >= 0.75)\n        .map(([value, txt]) => ({\n            value,\n            txt\n        }))\n\n// getPropability :: String -> FnStruct -> Number\nconst getPropability = (text, fn) => {\n    const match = getMatch(StemmSnowball, text, fn.sentences.de)[0]\n    return (match && match.value) !== undefined ? match.value : 0\n}\n\n// getMatches :: fn[] -> fn\nconst getMatches = functions => line =>\n    // {\n    // const matchTable = functions\n    functions\n        .reduce(\n            (ret, fn) =>\n                ret.concat([\n                    {\n                        propability: getPropability(line, fn),\n                        // fn: fn.fn,\n                        sentences: fn.sentences,\n                        path: fn.path\n                    }\n                ]),\n            []\n        )\n        .filter(fn => fn.propability > 0)\n        .sort((a, b) => b.propability - a.propability)\n\n// if (matchTable.length > 0) {\n//     const fn = matchTable[0]\n//     return fn\n// } else {\n//     return\n// }\n// }\n\n//\n// const toPathRequest = functions => request => {}\n\n// default :: Path => NlpRequest => Request\nmodule.exports = ({ path }) => {\n    // Load nlp functions\n    console.log('[Middleware] [NLP] Path:', path)\n    State.functions = getNlpFunctions(path)\n    console.log('GetNlpFunctions:', State.functions)\n    const findModule = getMatches(State.functions)\n    console.log('getMatch:', findModule)\n    return reqRes => {\n        console.log('[Middleware] [NLP] ReqRes:', reqRes)\n        if (Request.NLP.is(reqRes)) {\n            console.log('[Middleware] [NLP] Request:', reqRes)\n\n            // Request with nlp body\n            const sentence = reqRes.sentence\n\n            const matchTable = findModule(sentence)\n            console.log('MatchTable:', matchTable)\n            if (matchTable.length > 0) {\n                const match = matchTable[0]\n                const fnPath = match.path\n                const newRequest = Request.Request({\n                    path: fnPath,\n                    payload: { sentence }\n                })\n                console.log('[Middleware] [NLP] Generated Request:', newRequest)\n                return newRequest\n            }\n        }\n\n        return reqRes\n    }\n}\n\n//\n// -- Cmdline interface\n//\n//\n// const Readline = require('readline')\n// const input = Readline.createInterface(process.stdin, process.stdout)\n//\n// console.log('Loading..')\n// State.functions = getNlpFunctions('../../modules/functions')\n//\n// console.log('Test against:\\n')\n// State.functions\n//     // print sentences\n//     .map(f => f.sentences)\n//     .map(trace('Function:\\n'))\n//\n// input.setPrompt('\\n\\n> ')\n// input.prompt()\n// input\n//     .on('line', line => {\n//         if (line == 'exit') {\n//             input.close()\n//         }\n//         console.log('')\n//\n//         const stemmer = [/*StemmPorter2,*/ StemmSnowball, Normalize]\n//         const matchTable = State.functions\n//             .reduce(\n//                 (ret, fn) =>\n//                     ret.concat([\n//                         {\n//                             propability: getPropability(line, fn),\n//                             fn: fn.fn,\n//                             sentences: fn.sentences\n//                         }\n//                     ]),\n//                 []\n//             )\n//             .filter(fn => fn.propability > 0)\n//             .sort((a, b) => b.propability - a.propability)\n//         console.log('MatchTable:\\n', matchTable)\n//\n//         if (matchTable.length > 0) {\n//             const fn = matchTable[0]\n//             fn.fn(line)\n//         } else {\n//             console.log('No Match!')\n//         }\n//         input.prompt()\n//     })\n//     .on('close', () => {\n//         process.exit(0)\n//     })\n//\n","// TODO: Modify node search path for modules\n// See:\n// https://gist.github.com/branneman/8048520\nglobal.include = path => require(`${__dirname}/${path}`)\n\n//\n// -- Imports --\n//\nconst App = require('./data/app')\nconst Request = require('./data/request')\nconst Response = require('./data/response')\nconst HTTPGateway = require('./gateways/http')\nconst TelegramGateway = require('./gateways/telegram')\nconst NLPMiddleware = require('./middleware/nlp')\nconst Path = require('path')\n\n//\n// -- Config --\n//\nconst path = Path.resolve(process.cwd()) + '/functions'\nconst port = 3000\n\n//\n// -- Logic --\n//\nconst loadFunction = (req, path) => {\n    const fn = require(path)\n    return fn(req.payload)\n}\n\nconst Router = ({ path }) => request => {\n    if (Request.Request.is(request)) {\n        const fnPath = `${path}${request.path}`\n        try {\n            console.log('Load Function: Path: ', fnPath)\n            console.log('Load Function: Request: ', request)\n            return loadFunction(request, fnPath)\n        } catch (e) {\n            console.log('Load Function: Error: ', e)\n            return Response.Error(\"Can't find \" + fnPath)\n        }\n    } else {\n        return Response.Error('Invalid request.')\n    }\n}\n\nconst Service = App()\n    // Add data sources\n    .source(HTTPGateway({ port }))\n    // Add data manipulation pipeline steps\n    .add(NLPMiddleware({ path }))\n    // Add data processing\n    .do(Router({ path }))\n\n//\n// -- Exports --\n//\nmodule.exports = {\n    Service,\n    App,\n    Router,\n    Request,\n    Response,\n    HTTPGateway,\n    TelegramGateway,\n    NLPMiddleware\n}\n"]}