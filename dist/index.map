{"version":3,"sources":["data/app.js","data/request.js","data/response.js","gateways/http/web-service.js","gateways/http/index.js","gateways/telegram/index.js","middleware/nlp.js","index.js"],"names":["Let","require","App","fn","x","sources","layer","s","concat","l","f","reduce","g","In","dataPipeline","forEach","module","exports","Data","StringType","RequestType","String","Object","NLP","derive","val","sentence","Union","Result","Random","RandomOkType","Ok","val_list","random","Response","Err","Express","Compression","BodyParser","Url","Http","Log","log","HttpHeader","HttpRequest","isObject","obj","toPromise","p","then","Promise","resolve","toString","response","JSON","stringify","isObjEmpty","Boolean","keys","length","app","use","json","urlencoded","extended","all","req","res","next","url","parse","debug","request","method","headers","pathname","query","body","handler","r","write","end","program","port","prog","createServer","listen","WebService","Request","cfg","http","path","data","TeleBot","ParseMode","of","TelegramGateway","token","parseMode","Text","check","bot","on","msg","handle","text","answer","value","sendMessage","from","id","message_id","catch","e","start","Snowball","Natural","NlpToolkit","StopwordsIso","Fs","Language","State","getSubDirs","dir","readdirSync","map","file","filter","statSync","isDirectory","ret","d","getNlpFunctions","sentences","de","en","replace","cleanStopwords","lang","split","w","includes","join","trim","StemmSnowball","stemmer","cleanedText","toLowerCase","setCurrent","stem","getCurrent","Normalize","tokenizer","stemmed","calcSimilarity","withStr","matchStr","s1","s2","JaroWinklerDistance","getMatch","sort","val_a","s_a","val_b","s_b","txt","getPropability","match","undefined","getMatches","functions","line","propability","a","b","findModule","is","payload","matchTable","fnPath","newRequest","HTTPGateway","NLPMiddleware","Path","process","cwd","loadFunction","Router","Error","Service","add","do"],"mappings":"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","file":"index.map","sourceRoot":"../src","sourcesContent":["/*\n    App.js\n\n    Provides a data structure for basic app behaivor.\n*/\n\nconst { Let } = require('@fntk/utils')\n\n//\n// App\n//  * fn: The app logic\n//  * sources: A list of functions that act as data sources and generate data\n//  * layer: A list of functions that builds a pipeline and manipulate the\n//           data before reaching the app logic (fn)\n//\n// App :: Function -> List(Function) -> List(Function) -> Nothing\nconst App = (fn = x => x, sources = [], layer = []) => ({\n    // Here we add data sources. They can create data and feed in\n    // the system.\n    add: s => App(fn, sources.concat([s]), layer),\n\n    // Here we add a middleware layer to manipulate the data on his way\n    // trough the system, before it reaches it's final processing.\n    use: l => App(fn, sources, layer.concat([l])),\n\n    // Add the data processing. This is the main logic of the app.\n    do: f => App(f, sources, layer),\n\n    // Start the app\n    start: () =>\n        Let({\n            // Build the data pipeline. Incoming data is passed to all\n            // layers of middleware in the order we defined it earlier\n            // trough the .use() function.\n            dataPipeline: layer\n                // Add the program logic as last step, after the\n                // middleware layer\n                .concat(fn)\n                // Build the pipeline using composition\n                .reduce((f, g) => x => g(f(x)), x => x)\n        }).In(({ dataPipeline }) =>\n            // Hand the data processing pipeline to the data sources,\n            // so that every source can pass new data to the app.\n            sources.forEach(s => s(dataPipeline))\n        )\n})\n\nmodule.exports = App\n","/*\n    Request\n\n    Provides a data structure that represents an incoming request.\n*/\n\nconst { Data, StringType } = require('@fntk/types')\n\nconst RequestType = Data('Request', {\n    path: String,\n    payload: Object\n})\nRequestType.NLP = RequestType.derive(val => ({\n    path: '/',\n    payload: { sentence: StringType(val) }\n}))\n\n// const Request = Union('Request', {\n//     Request: RequestType,\n//     NLP: NLPRequestType\n// })\n\nmodule.exports = RequestType\n","/*\n    Request\n\n    Provides a data structure that represents an incoming request.\n*/\n\nconst { Union, Result } = require('@fntk/types')\nconst { Random } = require('@fntk/utils')\n\nconst RandomOkType = Result.Ok.derive(val_list => random(val_list))\n\nconst Response = Union('Response', {\n    Success: Result.Ok,\n    Error: Result.Err,\n    Random: RandomOkType\n})\n\nmodule.exports = Response\n","// Express\nconst Express = require('express')\nconst Compression = require('compression')\nconst BodyParser = require('body-parser')\n\n// Node\nconst Url = require('url')\nconst Http = require('http')\n\nconst { Data } = require('@fntk/types')\nconst { Log } = require('@fntk/utils')\n\nconst log = Log('WebService')\n\n//\n// -- Types\n//\n\nconst HttpHeader = Data('HTTPHeader', {\n    method: String,\n    url: String,\n    path: String,\n    headers: Object\n})\n\nconst HttpRequest = Data('HTTPRequest', {\n    http: HttpHeader,\n    data: Object\n})\n\n//\n// -- Helper\n//\nconst isObject = obj => obj !== null && typeof obj === 'object'\nconst toPromise = p => (p.then ? p : Promise.resolve(p))\nconst toString = response =>\n    isObject(response) ? JSON.stringify(response, 0, 4) : response\nconst isObjEmpty = obj => Boolean(Object.keys(obj).length)\n\n// app :: ()\nconst app = fn =>\n    Express()\n        .use(Compression()) // Compression support\n        .use(BodyParser.json()) // Automatic parsing of the response body\n        .use(BodyParser.urlencoded({ extended: true }))\n        // Catch route\n        .all('*', (req, res, next) => {\n            const url = Url.parse(req.url, true)\n            log.debug('URL', url)\n            const request = HttpRequest({\n                http: HttpHeader({\n                    method: req.method,\n                    headers: req.headers,\n                    url: req.url,\n                    path: url.pathname\n                }),\n                data: isObjEmpty(url.query) ? url.query : req.body\n            })\n            log.debug('Request', request)\n            const handler = r => toPromise(fn(r))\n            return handler(request)\n                .then(toString)\n                .then(response => {\n                    log.debug('[WebService] Response: ', response)\n                    res.write(response)\n                    return res.end()\n                })\n        })\n\n// program :: { Int, [ Route ]}\nconst program = fn => {\n    // Configuration\n    const port = 8000\n    const prog = app(fn)\n\n    return Http.createServer(prog).listen(port, () =>\n        log.debug(`Listening on: 0.0.0.0:${port}`)\n    )\n}\n\nmodule.exports = { program }\n","/*\n    HttpListener\n\n    Listen to http events and forward them back to the app for handling.\n*/\n\nconst WebService = require('./web-service')\nconst Request = require('../../data/request')\nconst { Log } = require('@fntk/utils')\n\nconst log = Log('HTTPGateway')\n\n// Get http requests, send them to the system for processing and\n// send the response after successfull handling.\nmodule.exports = cfg => fn =>\n    WebService.program(request => {\n        log.debug('HTTPRequest', request)\n        const req = Request({\n            path: request.http.path,\n            payload: request.data\n        })\n        log.debug('Request', req)\n        return fn(req)\n    })\n","/*\n    telegram.js\n\n    Get updates from telegram.\n*/\n\nconst Request = require('../../data/request')\nconst TeleBot = require('telebot')\nconst { Union, StringType } = require('@fntk/types')\nconst { Log } = require('@fntk/utils')\n\nconst log = Log('TelegramGateway')\n\n//\n// -- Helper --\n//\nconst toPromise = p => (p.then ? p : Promise.resolve(p))\n\n//\n// -- Types --\n//\n\nconst ParseMode = Union('TelegramParseMode', {\n    Text: StringType.of('Text'),\n    Markdown: StringType.of('Markdown'),\n    HTML: StringType.of('HTML')\n})\n\n// On token:\n// https://core.telegram.org/bots/api#authorizing-your-bot\n//\n// On parseMode:\n// https://core.telegram.org/bots/api#formatting-options\n//\nconst TelegramGateway = function({ token, parseMode = ParseMode.Text() }) {\n    log.debug('parseMode', parseMode)\n    ParseMode.check(parseMode)\n    log.debug('ParseMode', parseMode)\n    return fn => {\n        const bot = new TeleBot({\n            token,\n            polling: {\n                interval: 1000\n            }\n        })\n\n        // eslint-disable-next-line fp/no-unused-expression\n        bot.on('text', msg => {\n            log.debug('Request', msg)\n\n            const handle = req => toPromise(fn(req))\n            const req = Request.NLP(msg.text)\n            return handle(req)\n                .then(response => {\n                    log.debug('Response', response)\n                    const answer = String(response.value)\n                    log.debug('Answer', answer)\n                    return bot.sendMessage(msg.from.id, answer, {\n                        parseMode,\n                        replyToMessage: msg.message_id\n                    })\n                })\n                .catch(e => {\n                    log.debug('Error', e)\n                    return bot.sendMessage(msg.from.id, 'Internal Error', {\n                        replyToMessage: msg.message_id\n                    })\n                })\n        })\n\n        return bot.start()\n    }\n}\nTelegramGateway.ParseMode = ParseMode\n\nmodule.exports = TelegramGateway\n","/*\n    Route sentences to modules using nlp technics.\n*/\n\n// const Franc = require('franc') // Language detection\n// const Tokenizer = require('./stem/tokenizer')\nconst Snowball = require('snowball')\nconst Natural = require('natural') // sentence similarity\nconst NlpToolkit = require('nlp-toolkit')\nconst StopwordsIso = require('stopwords-iso')\nconst Fs = require('fs')\n\n// const GerSnowball = require('./snowball-ger')\n\nconst Request = require('../data/request')\nconst Response = require('../data/response')\nconst { Log } = require('@fntk/utils')\n\nconst log = Log('NLPMiddleware')\n\n// Languages :: Languages\nconst Language = {\n    de: 'German',\n    en: 'English'\n}\n\n// State :: State\nconst State = {\n    lang: 'de',\n    functions: []\n}\n\n//\n// -- Utils\n//\n\n// getSubDirs :: String => String[]\nconst getSubDirs = dir =>\n    Fs.readdirSync(dir)\n        // Convert the filename to a full path, filter out all\n        // directories and look recursively for more nested dirs.\n        .map(file => `${dir}/${file}`)\n        .filter(file => Fs.statSync(file).isDirectory())\n        .reduce(\n            (ret, d) =>\n                ret\n                    // Add found dirs to return value and look for\n                    // more nested dirs.\n                    .concat(d)\n                    .concat(getSubDirs(d)),\n            []\n        )\n\n// getNlpFunctions :: String => NlpFunction[]\nconst getNlpFunctions = dir =>\n    getSubDirs(dir).reduce((ret, path) => {\n        try {\n            const cfg = require(`${path}/function.json`)\n            if (cfg.sentences.de || cfg.sentences.en) {\n                return ret.concat([\n                    {\n                        path: path.replace(dir, ''),\n                        sentences: cfg.sentences\n                    }\n                ])\n            }\n        } catch (e) {\n            // Not found, or something else..\n            // console.error('NLPFunction:', e)\n        }\n        return ret\n    }, [])\n\n// cleanStopwords :: String => Language => String\nconst cleanStopwords = (text, lang) =>\n    text\n        // split sentence to an array of words\n        .split(' ')\n        // Filter all stopwords\n        .filter(w => !StopwordsIso[lang].includes(w))\n        // create string again\n        .join(' ')\n        .trim()\n\n// StemmSnowball :: String -> String\nconst StemmSnowball = text => {\n    if (text.length > 5) {\n        const stemmer = new Snowball(Language[State.lang])\n        const cleanedText = cleanStopwords(\n            text.toLowerCase().trim(),\n            State.lang\n        )\n        stemmer.setCurrent(cleanedText)\n        stemmer.stem()\n        return stemmer.getCurrent()\n    }\n    return text.toLowerCase()\n}\n\n// const GerStemmer = text => {\n//     const cleanedText = cleanStopwords(text.toLowerCase().trim(), State.lang)\n//     return GerSnowball(cleanedText)\n// }\n\n// Normalize :: String -> String\nconst Normalize = text => {\n    const token = NlpToolkit.tokenizer(text)\n    const stemmed = NlpToolkit.stemmer(token, { lang: State.lang })\n    return cleanStopwords(stemmed.join(' ').trim(), State.lang)\n}\n\n// Normalize :: (String => String) -> String -> String -> { val: Number, msg: String }\nconst calcSimilarity = (stemmer, withStr, matchStr) => {\n    const s1 = stemmer(matchStr.toLowerCase().trim())\n    const s2 = stemmer(withStr.toLowerCase().trim())\n    const value = Natural.JaroWinklerDistance(s1, s2)\n\n    return [value, s1]\n}\n\nconst getMatch = (stemmer, text, sentences) =>\n    sentences\n        .map(s => calcSimilarity(stemmer, text, s))\n        .sort(([val_a, s_a], [val_b, s_b]) => val_b - val_a)\n        // .map(log.debug('#'))\n        .filter(([val, sentence]) => val >= 0.75)\n        .map(([value, txt]) => ({\n            value,\n            txt\n        }))\n\n// getPropability :: String -> FnStruct -> Number\nconst getPropability = (text, fn) => {\n    // const match = getMatch(GerStemmer, text, fn.sentences.de)[0]\n    const match = getMatch(StemmSnowball, text, fn.sentences.de)[0]\n    return (match && match.value) !== undefined ? match.value : 0\n}\n\n// getMatches :: fn[] -> fn\nconst getMatches = functions => line =>\n    functions\n        .reduce(\n            (ret, fn) =>\n                ret.concat([\n                    {\n                        propability: getPropability(line, fn),\n                        // fn: fn.fn,\n                        sentences: fn.sentences,\n                        path: fn.path\n                    }\n                ]),\n            []\n        )\n        .filter(fn => fn.propability > 0)\n        .sort((a, b) => b.propability - a.propability)\n\n// default :: Path => NlpRequest => Request\nmodule.exports = ({ path }) => {\n    // Load nlp functions\n    log.debug('Path', path)\n    State.functions = getNlpFunctions(path)\n    log.debug('GetNlpFunctions', State.functions)\n    const findModule = getMatches(State.functions)\n    log.debug('getMatch', findModule)\n    return request => {\n        log.debug('request', request)\n        if (Request.NLP.is(request)) {\n            const sentence = request.payload.sentence\n            const matchTable = findModule(sentence)\n            log.debug('MatchTable', matchTable)\n            if (matchTable.length > 0) {\n                const match = matchTable[0]\n                const fnPath = match.path\n                const newRequest = Request({\n                    path: fnPath,\n                    payload: { sentence }\n                })\n                log.debug('NewRequest', newRequest)\n                return newRequest\n            }\n        }\n        return request\n    }\n}\n\n//\n// -- Cmdline interface\n//\n//\n// const Readline = require('readline')\n// const input = Readline.createInterface(process.stdin, process.stdout)\n//\n// log.debug('Loading..')\n// State.functions = getNlpFunctions('../../modules/functions')\n//\n// log.debug('Test against:\\n')\n// State.functions\n//     // print sentences\n//     .map(f => f.sentences)\n//     .map(trace('Function:\\n'))\n//\n// input.setPrompt('\\n\\n> ')\n// input.prompt()\n// input\n//     .on('line', line => {\n//         if (line == 'exit') {\n//             input.close()\n//         }\n//         log.debug('')\n//\n//         const stemmer = [/*StemmPorter2,*/ StemmSnowball, Normalize]\n//         const matchTable = State.functions\n//             .reduce(\n//                 (ret, fn) =>\n//                     ret.concat([\n//                         {\n//                             propability: getPropability(line, fn),\n//                             fn: fn.fn,\n//                             sentences: fn.sentences\n//                         }\n//                     ]),\n//                 []\n//             )\n//             .filter(fn => fn.propability > 0)\n//             .sort((a, b) => b.propability - a.propability)\n//         log.debug('MatchTable:\\n', matchTable)\n//\n//         if (matchTable.length > 0) {\n//             const fn = matchTable[0]\n//             fn.fn(line)\n//         } else {\n//             log.debug('No Match!')\n//         }\n//         input.prompt()\n//     })\n//     .on('close', () => {\n//         process.exit(0)\n//     })\n//\n","// TODO: Modify node search path for modules\n// See:\n// https://gist.github.com/branneman/8048520\n//global.include = path => require(`${__dirname}/${path}`)\n\n//\n// -- Imports --\n//\nconst App = require('./data/app')\nconst Request = require('./data/request')\nconst Response = require('./data/response')\nconst HTTPGateway = require('./gateways/http')\nconst TelegramGateway = require('./gateways/telegram')\nconst NLPMiddleware = require('./middleware/nlp')\nconst Path = require('path')\n\n//\n// -- Config --\n//\nconst path = Path.resolve(process.cwd()) + '/functions'\nconst port = 3000\n\n//\n// -- Logic --\n//\nconst loadFunction = (req, path) => {\n    const fn = require(path)\n    return fn(req.payload)\n}\n\nconst Router = ({ path }) => request => {\n    if (Request.is(request)) {\n        const fnPath = `${path}${request.path}`\n        try {\n            console.log('[Router] Path:', fnPath)\n            console.log('[Router] Request:', request)\n            return loadFunction(request, fnPath)\n        } catch (e) {\n            console.log('Load Function: Error: ', e)\n            return Response.Error(\"Can't find \" + fnPath)\n        }\n    }\n    return Response.Error('Invalid request: ' + request)\n}\n\nconst Service = App()\n    // Add data sources\n    .add(HTTPGateway({ port }))\n    // Add data manipulation pipeline steps\n    .use(NLPMiddleware({ path }))\n    // Add data processing\n    .do(Router({ path }))\n\n//\n// -- Exports --\n//\nmodule.exports = {\n    Service,\n    App,\n    Router,\n    Request,\n    Response,\n    HTTPGateway,\n    TelegramGateway,\n    NLPMiddleware\n}\n"]}